{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nvar _jsxFileName = \"C:\\\\Users\\\\Edeki Okoh1\\\\Desktop\\\\Modellytics\\\\Mobile\\\\EyeQ\\\\node_modules\\\\@react-navigation\\\\native\\\\dist\\\\createAppContainer.js\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React from 'react';\nimport Linking from \"react-native-web/dist/exports/Linking\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport BackHandler from \"react-native-web/dist/exports/BackHandler\";\nimport { NavigationActions, pathUtils, getNavigation, NavigationProvider } from '@react-navigation/core';\nimport invariant from \"./utils/invariant\";\nimport docsUrl from \"./utils/docsUrl\";\nvar urlToPathAndParams = pathUtils.urlToPathAndParams;\n\nfunction isStateful(props) {\n  return !props.navigation;\n}\n\nfunction validateProps(props) {\n  if (props.persistenceKey) {\n    console.warn('You passed persistenceKey prop to a navigator. ' + 'The persistenceKey prop was replaced by a more flexible persistence mechanism, ' + 'please see the navigation state persistence docs for more information. ' + 'Passing the persistenceKey prop is a no-op.');\n  }\n\n  if (isStateful(props)) {\n    return;\n  }\n\n  var navigation = props.navigation,\n      screenProps = props.screenProps,\n      persistNavigationState = props.persistNavigationState,\n      loadNavigationState = props.loadNavigationState,\n      containerProps = _objectWithoutProperties(props, [\"navigation\", \"screenProps\", \"persistNavigationState\", \"loadNavigationState\"]);\n\n  var keys = Object.keys(containerProps);\n\n  if (keys.length !== 0) {\n    throw new Error('This navigator has both navigation and container props, so it is ' + (\"unclear if it should own its own state. Remove props: \\\"\" + keys.join(', ') + \"\\\" \") + 'if the navigator should get its state from the navigation prop. If the ' + 'navigator should maintain its own state, do not pass a navigation prop.');\n  }\n\n  invariant(persistNavigationState === undefined && loadNavigationState === undefined || typeof persistNavigationState === 'function' && typeof loadNavigationState === 'function', 'both persistNavigationState and loadNavigationState must either be undefined, or be functions');\n}\n\nvar _statefulContainerCount = 0;\nexport function _TESTING_ONLY_reset_container_count() {\n  _statefulContainerCount = 0;\n}\nvar _reactNavigationIsHydratingState = false;\nexport default function createNavigationContainer(Component) {\n  var NavigationContainer = function (_React$Component) {\n    _inherits(NavigationContainer, _React$Component);\n\n    var _super = _createSuper(NavigationContainer);\n\n    _createClass(NavigationContainer, null, [{\n      key: \"getDerivedStateFromProps\",\n      value: function getDerivedStateFromProps(nextProps) {\n        validateProps(nextProps);\n        return null;\n      }\n    }]);\n\n    function NavigationContainer(props) {\n      var _this;\n\n      _classCallCheck(this, NavigationContainer);\n\n      _this = _super.call(this, props);\n      _this.subs = null;\n      _this._actionEventSubscribers = new Set();\n\n      _this._handleOpenURL = function (_ref) {\n        var url = _ref.url;\n        var _this$props = _this.props,\n            enableURLHandling = _this$props.enableURLHandling,\n            uriPrefix = _this$props.uriPrefix;\n\n        if (enableURLHandling === false) {\n          return;\n        }\n\n        var parsedUrl = urlToPathAndParams(url, uriPrefix);\n\n        if (parsedUrl) {\n          var path = parsedUrl.path,\n              params = parsedUrl.params;\n          var action = Component.router.getActionForPathAndParams(path, params);\n\n          if (action) {\n            _this.dispatch(action);\n          }\n        }\n      };\n\n      _this._persistNavigationState = function _callee(nav) {\n        var persistNavigationState;\n        return _regeneratorRuntime.async(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                persistNavigationState = _this.props.persistNavigationState;\n\n                if (!persistNavigationState) {\n                  _context.next = 10;\n                  break;\n                }\n\n                _context.prev = 2;\n                _context.next = 5;\n                return _regeneratorRuntime.awrap(persistNavigationState(nav));\n\n              case 5:\n                _context.next = 10;\n                break;\n\n              case 7:\n                _context.prev = 7;\n                _context.t0 = _context[\"catch\"](2);\n                console.warn('Uncaught exception while calling persistNavigationState()! You should handle exceptions thrown from persistNavigationState(), ignoring them may result in undefined behavior.');\n\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, null, null, [[2, 7]], Promise);\n      };\n\n      _this.dispatch = function (action) {\n        if (_this.props.navigation) {\n          return _this.props.navigation.dispatch(action);\n        }\n\n        _this._navState = _this._navState || _this.state.nav;\n        var lastNavState = _this._navState;\n        invariant(lastNavState, 'should be set in constructor if stateful');\n        var reducedState = Component.router.getStateForAction(action, lastNavState);\n        var navState = reducedState === null ? lastNavState : reducedState;\n\n        var dispatchActionEvents = function dispatchActionEvents() {\n          _this._actionEventSubscribers.forEach(function (subscriber) {\n            return subscriber({\n              type: 'action',\n              action: action,\n              state: navState,\n              lastState: lastNavState\n            });\n          });\n        };\n\n        if (reducedState === null) {\n          dispatchActionEvents();\n          return true;\n        }\n\n        if (navState !== lastNavState) {\n          _this._navState = navState;\n\n          _this.setState({\n            nav: navState\n          }, function () {\n            _this._onNavigationStateChange(lastNavState, navState, action);\n\n            dispatchActionEvents();\n\n            _this._persistNavigationState(navState);\n          });\n\n          return true;\n        }\n\n        dispatchActionEvents();\n        return false;\n      };\n\n      _this._getScreenProps = function () {\n        return _this.props.screenProps;\n      };\n\n      validateProps(props);\n      _this._initialAction = NavigationActions.init();\n\n      if (_this._isStateful() && BackHandler && typeof BackHandler.addEventListener === 'function') {\n        _this.subs = BackHandler.addEventListener('hardwareBackPress', function () {\n          if (!_this._isMounted) {\n            _this.subs && _this.subs.remove();\n          } else {\n            return _this.dispatch(NavigationActions.back());\n          }\n        });\n      }\n\n      _this.state = {\n        nav: _this._isStateful() && !props.loadNavigationState ? Component.router.getStateForAction(_this._initialAction) : null\n      };\n      return _this;\n    }\n\n    _createClass(NavigationContainer, [{\n      key: \"_renderLoading\",\n      value: function _renderLoading() {\n        return this.props.renderLoadingExperimental ? this.props.renderLoadingExperimental() : null;\n      }\n    }, {\n      key: \"_isStateful\",\n      value: function _isStateful() {\n        return isStateful(this.props);\n      }\n    }, {\n      key: \"_validateProps\",\n      value: function _validateProps(props) {\n        if (this._isStateful()) {\n          return;\n        }\n\n        var navigation = props.navigation,\n            screenProps = props.screenProps,\n            containerProps = _objectWithoutProperties(props, [\"navigation\", \"screenProps\"]);\n\n        var keys = Object.keys(containerProps);\n\n        if (keys.length !== 0) {\n          throw new Error('This navigator has both navigation and container props, so it is ' + (\"unclear if it should own its own state. Remove props: \\\"\" + keys.join(', ') + \"\\\" \") + 'if the navigator should get its state from the navigation prop. If the ' + 'navigator should maintain its own state, do not pass a navigation prop.');\n        }\n      }\n    }, {\n      key: \"_onNavigationStateChange\",\n      value: function _onNavigationStateChange(prevNav, nav, action) {\n        if (typeof this.props.onNavigationStateChange === 'undefined' && this._isStateful() && !!process.env.REACT_NAV_LOGGING) {\n          if (console.group) {\n            console.group('Navigation Dispatch: ');\n            console.log('Action: ', action);\n            console.log('New State: ', nav);\n            console.log('Last State: ', prevNav);\n            console.groupEnd();\n          } else {\n            console.log('Navigation Dispatch: ', {\n              action: action,\n              newState: nav,\n              lastState: prevNav\n            });\n          }\n\n          return;\n        }\n\n        if (typeof this.props.onNavigationStateChange === 'function') {\n          this.props.onNavigationStateChange(prevNav, nav, action);\n        }\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate() {\n        if (this._navState === this.state.nav) {\n          this._navState = null;\n        }\n      }\n    }, {\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        var _this2 = this;\n\n        var parsedUrl, userProvidedStartupState, _await$this$getStartu, action, startupState, _parsedUrl, path, params, urlAction, dispatchActions;\n\n        return _regeneratorRuntime.async(function componentDidMount$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                this._isMounted = true;\n\n                if (this._isStateful()) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 3:\n                if (__DEV__ && !this.props.detached) {\n                  if (_statefulContainerCount > 0) {\n                    if (Platform.OS === 'ios') {\n                      console.warn(\"You should only render one navigator explicitly in your app, and other navigators should be rendered by including them in that navigator. Full details at: \" + docsUrl('common-mistakes.html#explicitly-rendering-more-than-one-navigator'));\n                    }\n                  }\n                }\n\n                _statefulContainerCount++;\n                Linking.addEventListener('url', this._handleOpenURL);\n                parsedUrl = null;\n                userProvidedStartupState = null;\n\n                if (!(this.props.enableURLHandling !== false)) {\n                  _context2.next = 14;\n                  break;\n                }\n\n                _context2.next = 11;\n                return _regeneratorRuntime.awrap(this.getStartupParams());\n\n              case 11:\n                _await$this$getStartu = _context2.sent;\n                parsedUrl = _await$this$getStartu.parsedUrl;\n                userProvidedStartupState = _await$this$getStartu.userProvidedStartupState;\n\n              case 14:\n                action = this._initialAction;\n                startupState = this.state.nav;\n\n                if (!startupState && !userProvidedStartupState) {\n                  !!process.env.REACT_NAV_LOGGING && console.log('Init new Navigation State');\n                  startupState = Component.router.getStateForAction(action);\n                }\n\n                if (userProvidedStartupState) {\n                  startupState = userProvidedStartupState;\n                  _reactNavigationIsHydratingState = true;\n                }\n\n                if (parsedUrl) {\n                  _parsedUrl = parsedUrl, path = _parsedUrl.path, params = _parsedUrl.params;\n                  urlAction = Component.router.getActionForPathAndParams(path, params);\n\n                  if (urlAction) {\n                    !!process.env.REACT_NAV_LOGGING && console.log('Applying Navigation Action for Initial URL:', parsedUrl);\n                    action = urlAction;\n                    startupState = Component.router.getStateForAction(urlAction, startupState);\n                  }\n                }\n\n                dispatchActions = function dispatchActions() {\n                  return _this2._actionEventSubscribers.forEach(function (subscriber) {\n                    return subscriber({\n                      type: 'action',\n                      action: action,\n                      state: _this2.state.nav,\n                      lastState: null\n                    });\n                  });\n                };\n\n                if (!(startupState === this.state.nav)) {\n                  _context2.next = 23;\n                  break;\n                }\n\n                dispatchActions();\n                return _context2.abrupt(\"return\");\n\n              case 23:\n                this.setState({\n                  nav: startupState\n                }, function () {\n                  _reactNavigationIsHydratingState = false;\n                  dispatchActions();\n                });\n\n              case 24:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, null, this, null, Promise);\n      }\n    }, {\n      key: \"getStartupParams\",\n      value: function getStartupParams() {\n        var _this$props2, uriPrefix, loadNavigationState, url, loadedNavState, _await$Promise$all, _await$Promise$all2;\n\n        return _regeneratorRuntime.async(function getStartupParams$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _this$props2 = this.props, uriPrefix = _this$props2.uriPrefix, loadNavigationState = _this$props2.loadNavigationState;\n                _context3.prev = 1;\n                _context3.next = 4;\n                return _regeneratorRuntime.awrap(Promise.all([Linking.getInitialURL(), loadNavigationState && loadNavigationState()]));\n\n              case 4:\n                _await$Promise$all = _context3.sent;\n                _await$Promise$all2 = _slicedToArray(_await$Promise$all, 2);\n                url = _await$Promise$all2[0];\n                loadedNavState = _await$Promise$all2[1];\n                _context3.next = 12;\n                break;\n\n              case 10:\n                _context3.prev = 10;\n                _context3.t0 = _context3[\"catch\"](1);\n\n              case 12:\n                return _context3.abrupt(\"return\", {\n                  parsedUrl: url && urlToPathAndParams(url, uriPrefix),\n                  userProvidedStartupState: loadedNavState\n                });\n\n              case 13:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, null, this, [[1, 10]], Promise);\n      }\n    }, {\n      key: \"componentDidCatch\",\n      value: function componentDidCatch(e) {\n        if (_reactNavigationIsHydratingState) {\n          _reactNavigationIsHydratingState = false;\n          console.warn('Uncaught exception while starting app from persisted navigation state! Trying to render again with a fresh navigation state...');\n          this.dispatch(NavigationActions.init());\n        } else {\n          throw e;\n        }\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        this._isMounted = false;\n        Linking.removeEventListener('url', this._handleOpenURL);\n        this.subs && this.subs.remove();\n\n        if (this._isStateful()) {\n          _statefulContainerCount--;\n        }\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _this3 = this;\n\n        var navigation = this.props.navigation;\n\n        if (this._isStateful()) {\n          var navState = this.state.nav;\n\n          if (!navState) {\n            return this._renderLoading();\n          }\n\n          if (!this._navigation || this._navigation.state !== navState) {\n            this._navigation = getNavigation(Component.router, navState, this.dispatch, this._actionEventSubscribers, this._getScreenProps, function () {\n              return _this3._navigation;\n            });\n          }\n\n          navigation = this._navigation;\n        }\n\n        invariant(navigation, 'failed to get navigation');\n        return React.createElement(NavigationProvider, {\n          value: navigation,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 347,\n            columnNumber: 14\n          }\n        }, React.createElement(Component, _extends({}, this.props, {\n          navigation: navigation,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 348,\n            columnNumber: 11\n          }\n        })));\n      }\n    }]);\n\n    return NavigationContainer;\n  }(React.Component);\n\n  NavigationContainer.router = Component.router;\n  NavigationContainer.navigationOptions = null;\n  return NavigationContainer;\n}","map":{"version":3,"sources":["C:/Users/Edeki Okoh1/Desktop/Modellytics/Mobile/EyeQ/node_modules/@react-navigation/native/dist/createAppContainer.js"],"names":["React","NavigationActions","pathUtils","getNavigation","NavigationProvider","invariant","docsUrl","urlToPathAndParams","isStateful","props","navigation","validateProps","persistenceKey","console","warn","screenProps","persistNavigationState","loadNavigationState","containerProps","keys","Object","length","Error","join","undefined","_statefulContainerCount","_TESTING_ONLY_reset_container_count","_reactNavigationIsHydratingState","createNavigationContainer","Component","NavigationContainer","nextProps","subs","_actionEventSubscribers","Set","_handleOpenURL","url","enableURLHandling","uriPrefix","parsedUrl","path","params","action","router","getActionForPathAndParams","dispatch","_persistNavigationState","nav","_navState","state","lastNavState","reducedState","getStateForAction","navState","dispatchActionEvents","forEach","subscriber","type","lastState","setState","_onNavigationStateChange","_getScreenProps","_initialAction","init","_isStateful","BackHandler","addEventListener","_isMounted","remove","back","renderLoadingExperimental","prevNav","onNavigationStateChange","process","env","REACT_NAV_LOGGING","group","log","groupEnd","newState","__DEV__","detached","Platform","OS","Linking","userProvidedStartupState","getStartupParams","startupState","urlAction","dispatchActions","Promise","all","getInitialURL","loadedNavState","e","removeEventListener","_renderLoading","_navigation","navigationOptions"],"mappings":"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","sourcesContent":["import React from 'react';\r\nimport { Linking, Platform, BackHandler } from 'react-native';\r\nimport { NavigationActions, pathUtils, getNavigation, NavigationProvider } from '@react-navigation/core';\r\nimport invariant from './utils/invariant';\r\nimport docsUrl from './utils/docsUrl';\r\n\r\nconst { urlToPathAndParams } = pathUtils;\r\n\r\nfunction isStateful(props) {\r\n  return !props.navigation;\r\n}\r\n\r\nfunction validateProps(props) {\r\n  if (props.persistenceKey) {\r\n    console.warn('You passed persistenceKey prop to a navigator. ' + 'The persistenceKey prop was replaced by a more flexible persistence mechanism, ' + 'please see the navigation state persistence docs for more information. ' + 'Passing the persistenceKey prop is a no-op.');\r\n  }\r\n  if (isStateful(props)) {\r\n    return;\r\n  }\r\n  /* eslint-disable no-unused-vars */\r\n  const {\r\n    navigation,\r\n    screenProps,\r\n    persistNavigationState,\r\n    loadNavigationState,\r\n    ...containerProps\r\n  } = props;\r\n  /* eslint-enable no-unused-vars */\r\n\r\n  const keys = Object.keys(containerProps);\r\n\r\n  if (keys.length !== 0) {\r\n    throw new Error('This navigator has both navigation and container props, so it is ' + `unclear if it should own its own state. Remove props: \"${keys.join(', ')}\" ` + 'if the navigator should get its state from the navigation prop. If the ' + 'navigator should maintain its own state, do not pass a navigation prop.');\r\n  }\r\n  invariant(persistNavigationState === undefined && loadNavigationState === undefined || typeof persistNavigationState === 'function' && typeof loadNavigationState === 'function', 'both persistNavigationState and loadNavigationState must either be undefined, or be functions');\r\n}\r\n\r\n// Track the number of stateful container instances. Warn if >0 and not using the\r\n// detached prop to explicitly acknowledge the behavior. We should deprecated implicit\r\n// stateful navigation containers in a future release and require a provider style pattern\r\n// instead in order to eliminate confusion entirely.\r\nlet _statefulContainerCount = 0;\r\nexport function _TESTING_ONLY_reset_container_count() {\r\n  _statefulContainerCount = 0;\r\n}\r\n\r\n// We keep a global flag to catch errors during the state persistence hydrating scenario.\r\n// The innermost navigator who catches the error will dispatch a new init action.\r\nlet _reactNavigationIsHydratingState = false;\r\n// Unfortunate to use global state here, but it seems necessesary for the time\r\n// being. There seems to be some problems with cascading componentDidCatch\r\n// handlers. Ideally the inner non-stateful navigator catches the error and\r\n// re-throws it, to be caught by the top-level stateful navigator.\r\n\r\n/**\r\n * Create an HOC that injects the navigation and manages the navigation state\r\n * in case it's not passed from above.\r\n * This allows to use e.g. the StackNavigator and TabNavigator as root-level\r\n * components.\r\n */\r\nexport default function createNavigationContainer(Component) {\r\n  class NavigationContainer extends React.Component {\r\n    subs = null;\r\n\r\n    static router = Component.router;\r\n    static navigationOptions = null;\r\n\r\n    static getDerivedStateFromProps(nextProps) {\r\n      validateProps(nextProps);\r\n      return null;\r\n    }\r\n\r\n    _actionEventSubscribers = new Set();\r\n\r\n    constructor(props) {\r\n      super(props);\r\n\r\n      validateProps(props);\r\n\r\n      this._initialAction = NavigationActions.init();\r\n\r\n      if (this._isStateful() && BackHandler && typeof BackHandler.addEventListener === 'function') {\r\n        this.subs = BackHandler.addEventListener('hardwareBackPress', () => {\r\n          if (!this._isMounted) {\r\n            this.subs && this.subs.remove();\r\n          } else {\r\n            // dispatch returns true if the action results in a state change,\r\n            // and false otherwise. This maps well to what BackHandler expects\r\n            // from a callback -- true if handled, false if not handled\r\n            return this.dispatch(NavigationActions.back());\r\n          }\r\n        });\r\n      }\r\n\r\n      this.state = {\r\n        nav: this._isStateful() && !props.loadNavigationState ? Component.router.getStateForAction(this._initialAction) : null\r\n      };\r\n    }\r\n\r\n    _renderLoading() {\r\n      return this.props.renderLoadingExperimental ? this.props.renderLoadingExperimental() : null;\r\n    }\r\n\r\n    _isStateful() {\r\n      return isStateful(this.props);\r\n    }\r\n\r\n    _validateProps(props) {\r\n      if (this._isStateful()) {\r\n        return;\r\n      }\r\n\r\n      // eslint-disable-next-line no-unused-vars\r\n      const { navigation, screenProps, ...containerProps } = props;\r\n\r\n      const keys = Object.keys(containerProps);\r\n\r\n      if (keys.length !== 0) {\r\n        throw new Error('This navigator has both navigation and container props, so it is ' + `unclear if it should own its own state. Remove props: \"${keys.join(', ')}\" ` + 'if the navigator should get its state from the navigation prop. If the ' + 'navigator should maintain its own state, do not pass a navigation prop.');\r\n      }\r\n    }\r\n\r\n    _handleOpenURL = ({ url }) => {\r\n      const { enableURLHandling, uriPrefix } = this.props;\r\n      if (enableURLHandling === false) {\r\n        return;\r\n      }\r\n      const parsedUrl = urlToPathAndParams(url, uriPrefix);\r\n      if (parsedUrl) {\r\n        const { path, params } = parsedUrl;\r\n        const action = Component.router.getActionForPathAndParams(path, params);\r\n        if (action) {\r\n          this.dispatch(action);\r\n        }\r\n      }\r\n    };\r\n\r\n    _onNavigationStateChange(prevNav, nav, action) {\r\n      if (typeof this.props.onNavigationStateChange === 'undefined' && this._isStateful() && !!process.env.REACT_NAV_LOGGING) {\r\n        if (console.group) {\r\n          console.group('Navigation Dispatch: ');\r\n          console.log('Action: ', action);\r\n          console.log('New State: ', nav);\r\n          console.log('Last State: ', prevNav);\r\n          console.groupEnd();\r\n        } else {\r\n          console.log('Navigation Dispatch: ', {\r\n            action,\r\n            newState: nav,\r\n            lastState: prevNav\r\n          });\r\n        }\r\n        return;\r\n      }\r\n\r\n      if (typeof this.props.onNavigationStateChange === 'function') {\r\n        this.props.onNavigationStateChange(prevNav, nav, action);\r\n      }\r\n    }\r\n\r\n    componentDidUpdate() {\r\n      // Clear cached _navState every tick\r\n      if (this._navState === this.state.nav) {\r\n        this._navState = null;\r\n      }\r\n    }\r\n\r\n    async componentDidMount() {\r\n      this._isMounted = true;\r\n      if (!this._isStateful()) {\r\n        return;\r\n      }\r\n\r\n      if (__DEV__ && !this.props.detached) {\r\n        if (_statefulContainerCount > 0) {\r\n          // Temporarily only show this on iOS due to this issue:\r\n          // https://github.com/react-navigation/react-navigation/issues/4196#issuecomment-390827829\r\n          if (Platform.OS === 'ios') {\r\n            console.warn(`You should only render one navigator explicitly in your app, and other navigators should be rendered by including them in that navigator. Full details at: ${docsUrl('common-mistakes.html#explicitly-rendering-more-than-one-navigator')}`);\r\n          }\r\n        }\r\n      }\r\n      _statefulContainerCount++;\r\n      Linking.addEventListener('url', this._handleOpenURL);\r\n\r\n      // Pull out anything that can impact state\r\n      let parsedUrl = null;\r\n      let userProvidedStartupState = null;\r\n      if (this.props.enableURLHandling !== false) {\r\n        ({\r\n          parsedUrl,\r\n          userProvidedStartupState\r\n        } = await this.getStartupParams());\r\n      }\r\n\r\n      // Initialize state. This must be done *after* any async code\r\n      // so we don't end up with a different value for this.state.nav\r\n      // due to changes while async function was resolving\r\n      let action = this._initialAction;\r\n      let startupState = this.state.nav;\r\n      if (!startupState && !userProvidedStartupState) {\r\n        !!process.env.REACT_NAV_LOGGING && console.log('Init new Navigation State');\r\n        startupState = Component.router.getStateForAction(action);\r\n      }\r\n\r\n      // Pull user-provided persisted state\r\n      if (userProvidedStartupState) {\r\n        startupState = userProvidedStartupState;\r\n        _reactNavigationIsHydratingState = true;\r\n      }\r\n\r\n      // Pull state out of URL\r\n      if (parsedUrl) {\r\n        const { path, params } = parsedUrl;\r\n        const urlAction = Component.router.getActionForPathAndParams(path, params);\r\n        if (urlAction) {\r\n          !!process.env.REACT_NAV_LOGGING && console.log('Applying Navigation Action for Initial URL:', parsedUrl);\r\n          action = urlAction;\r\n          startupState = Component.router.getStateForAction(urlAction, startupState);\r\n        }\r\n      }\r\n\r\n      const dispatchActions = () => this._actionEventSubscribers.forEach(subscriber => subscriber({\r\n        type: 'action',\r\n        action,\r\n        state: this.state.nav,\r\n        lastState: null\r\n      }));\r\n\r\n      if (startupState === this.state.nav) {\r\n        dispatchActions();\r\n        return;\r\n      }\r\n\r\n      // eslint-disable-next-line react/no-did-mount-set-state\r\n      this.setState({ nav: startupState }, () => {\r\n        _reactNavigationIsHydratingState = false;\r\n        dispatchActions();\r\n      });\r\n    }\r\n\r\n    async getStartupParams() {\r\n      const { uriPrefix, loadNavigationState } = this.props;\r\n      let url, loadedNavState;\r\n      try {\r\n        [url, loadedNavState] = await Promise.all([Linking.getInitialURL(), loadNavigationState && loadNavigationState()]);\r\n      } catch (err) {\r\n        // ignore\r\n      }\r\n      return {\r\n        parsedUrl: url && urlToPathAndParams(url, uriPrefix),\r\n        userProvidedStartupState: loadedNavState\r\n      };\r\n    }\r\n\r\n    componentDidCatch(e) {\r\n      if (_reactNavigationIsHydratingState) {\r\n        _reactNavigationIsHydratingState = false;\r\n        console.warn('Uncaught exception while starting app from persisted navigation state! Trying to render again with a fresh navigation state...');\r\n        this.dispatch(NavigationActions.init());\r\n      } else {\r\n        throw e;\r\n      }\r\n    }\r\n\r\n    _persistNavigationState = async nav => {\r\n      const { persistNavigationState } = this.props;\r\n      if (persistNavigationState) {\r\n        try {\r\n          await persistNavigationState(nav);\r\n        } catch (err) {\r\n          console.warn('Uncaught exception while calling persistNavigationState()! You should handle exceptions thrown from persistNavigationState(), ignoring them may result in undefined behavior.');\r\n        }\r\n      }\r\n    };\r\n\r\n    componentWillUnmount() {\r\n      this._isMounted = false;\r\n      Linking.removeEventListener('url', this._handleOpenURL);\r\n      this.subs && this.subs.remove();\r\n\r\n      if (this._isStateful()) {\r\n        _statefulContainerCount--;\r\n      }\r\n    }\r\n\r\n    // Per-tick temporary storage for state.nav\r\n\r\n    dispatch = action => {\r\n      if (this.props.navigation) {\r\n        return this.props.navigation.dispatch(action);\r\n      }\r\n\r\n      // navState will have the most up-to-date value, because setState sometimes behaves asyncronously\r\n      this._navState = this._navState || this.state.nav;\r\n      const lastNavState = this._navState;\r\n      invariant(lastNavState, 'should be set in constructor if stateful');\r\n      const reducedState = Component.router.getStateForAction(action, lastNavState);\r\n      const navState = reducedState === null ? lastNavState : reducedState;\r\n\r\n      const dispatchActionEvents = () => {\r\n        this._actionEventSubscribers.forEach(subscriber => subscriber({\r\n          type: 'action',\r\n          action,\r\n          state: navState,\r\n          lastState: lastNavState\r\n        }));\r\n      };\r\n\r\n      if (reducedState === null) {\r\n        // The router will return null when action has been handled and the state hasn't changed.\r\n        // dispatch returns true when something has been handled.\r\n        dispatchActionEvents();\r\n        return true;\r\n      }\r\n\r\n      if (navState !== lastNavState) {\r\n        // Cache updates to state.nav during the tick to ensure that subsequent calls will not discard this change\r\n        this._navState = navState;\r\n        this.setState({ nav: navState }, () => {\r\n          this._onNavigationStateChange(lastNavState, navState, action);\r\n          dispatchActionEvents();\r\n          this._persistNavigationState(navState);\r\n        });\r\n        return true;\r\n      }\r\n\r\n      dispatchActionEvents();\r\n      return false;\r\n    };\r\n\r\n    _getScreenProps = () => this.props.screenProps;\r\n\r\n    render() {\r\n      let navigation = this.props.navigation;\r\n      if (this._isStateful()) {\r\n        const navState = this.state.nav;\r\n        if (!navState) {\r\n          return this._renderLoading();\r\n        }\r\n        if (!this._navigation || this._navigation.state !== navState) {\r\n          this._navigation = getNavigation(Component.router, navState, this.dispatch, this._actionEventSubscribers, this._getScreenProps, () => this._navigation);\r\n        }\r\n        navigation = this._navigation;\r\n      }\r\n      invariant(navigation, 'failed to get navigation');\r\n      return <NavigationProvider value={navigation}>\r\n          <Component {...this.props} navigation={navigation} />\r\n        </NavigationProvider>;\r\n    }\r\n  }\r\n\r\n  return NavigationContainer;\r\n}"]},"metadata":{},"sourceType":"module"}